# **Go 프로젝트 패키지 구조 가이드**

## **1\. 소개**

이 문서는 Go 언어 기반 프로젝트를 위한 표준 패키지 구조를 제안하며, 각 구성 요소의 역할과 책임을 명확히 정의하는 것을 목표로 합니다. 이 구조는 현대적인 소프트웨어 개발 원칙에 기반하여 다음과 같은 핵심 목표를 가지고 설계되었습니다.

* **관심사의 분리 (Separation of Concerns):** 각 컴포넌트가 특정 책임에만 집중하도록 하여 코드의 복잡성을 관리합니다. 예를 들어, 데이터베이스 상호작용 로직은 비즈니스 규칙 결정 로직과 분리됩니다. 이는 개별 부분의 이해와 수정을 용이하게 만듭니다.
* **명확한 의존성 관리 (Clear Dependency Management):** 계층 간, 패키지 간 의존성 흐름을 명확하고 예측 가능하게 제어합니다. 이는 순환 의존성을 방지하고, 변경 사항이 시스템 전체에 미치는 영향을 최소화하여 코드 안정성을 높입니다.
* **테스트 용이성 (Testability):** 인터페이스 기반 설계와 의존성 주입을 통해 각 컴포넌트를 격리하고 독립적으로 테스트할 수 있도록 지원합니다. 이는 단위 테스트 및 통합 테스트 작성을 용이하게 하여 코드 품질과 신뢰도를 향상시킵니다.
* **유지보수성 및 확장성 (Maintainability & Scalability):** 잘 정의된 구조는 코드 베이스가 커지더라도 이해하기 쉽고 수정하기 용이하게 유지합니다. 또한, 새로운 기능을 추가하거나 기존 기능을 변경할 때 유연하게 대처할 수 있는 기반을 제공하여 프로젝트의 장기적인 성장을 지원합니다.

이 가이드를 통해 프로젝트 참여자들은 일관된 코드 구조 위에서 협업함으로써 생산성을 높이고, 잠재적인 설계 오류를 줄이며, 보다 견고하고 발전 가능한 애플리케이션을 구축할 수 있습니다.

## **2\. 최상위 디렉토리 구조**

프로젝트 루트 디렉토리는 일반적으로 다음과 같은 구조를 따르는 것을 권장합니다.

myproject/  
├── cmd/         \# 애플리케이션 실행 및 의존성 조립 (Entry Points & Wiring)  
├── internal/    \# 비즈니스 로직 구성 (Controller, Service 등)  
│   ├── controller/ \# 요청 처리 및 응답 변환 (Request Handling & Response Mapping)  
│   └── service/    \# 핵심 비즈니스 로직 및 흐름 제어 (Core Business Logic & Orchestration)  
├── lib/         \# 핵심 추상화: 인터페이스 및 데이터 구조 (Core Abstractions)  
├── pkg/         \# 구현: 인터페이스 구현 및 인프라 로직 (Implementations)  
├── proto/       \# 프로토콜 정의 원본 (IDL Sources)  
├── go.mod       \# Go 모듈 정의 파일  
└── go.sum       \# Go 모듈 체크섬 파일

## **3\. 상세 디렉토리 설명**

각 최상위 디렉토리의 역할과 책임, 그리고 그 존재 이유는 다음과 같습니다.

### **3.1. cmd/ \- 실행 및 조립**

* **역할:** 애플리케이션의 **실행 진입점 (main 패키지)** 입니다. 여러 계층에 흩어져 있는 컴포넌트들을 모아 **실제 실행 가능한 애플리케이션으로 조립(Wiring)하고 구동**하는 핵심적인 책임을 갖습니다.
* **구조:** 일반적으로 각 실행 파일(예: 웹 서버, 마이크로서비스 API, 배치 작업 워커, CLI 도구) 단위로 하위 디렉토리를 생성합니다 (예: cmd/api/, cmd/worker/, cmd/cli/). 이는 프로젝트가 여러 실행 파일을 가질 때 명확한 분리를 가능하게 합니다.
* **주요 책임:**
    * **구현체 초기화:** pkg/ 디렉토리에 정의된 구체적인 구현체들(예: zerolog 로거, pgx PostgreSQL 커넥션 풀, bcrypt 패스워드 해셔)의 인스턴스를 생성하고 필요한 설정을 적용합니다.
    * **서비스 및 컨트롤러 초기화:** internal/service/ 와 internal/controller/ 에 정의된 비즈니스 로직 및 요청 처리 컴포넌트들을 초기화합니다.
    * **의존성 주입 (Dependency Injection):** 이 디렉토리의 가장 중요한 역할 중 하나입니다. 애플리케이션의 "접착제" 역할을 하며, 인터페이스와 구현체를 연결합니다.
        * service 컴포넌트가 의존하는 lib/ 인터페이스(예: UserRepository)에 pkg/ 에서 생성한 해당 구현체 인스턴스(예: PostgresUserRepository)를 주입합니다.
        * controller 컴포넌트가 의존하는 service 인스턴스와 필요한 lib/ 인터페이스(예: InputValidator)를 주입합니다. 이 과정을 통해 각 컴포넌트는 자신이 의존하는 대상의 구체적인 구현을 알 필요 없이 인터페이스에만 의존하게 됩니다.
    * **환경 설정 및 초기화:** 애플리케이션 실행에 필요한 환경 변수 로드, 커맨드 라인 플래그 파싱, 설정 파일 읽기 등의 준비 작업을 수행합니다.
    * **애플리케이션 구동:** 모든 준비와 조립이 완료되면, 최종적으로 애플리케이션을 시작합니다 (예: http.ListenAndServe 호출, gRPC 서버 시작, 워커 루프 실행).
* **원칙:** **절대로 비즈니스 로직이나 복잡한 알고리즘, 데이터 변환 로직 등을 포함하지 않습니다.** cmd/ 는 오직 애플리케이션의 **설정(Configuration), 조립(Wiring), 실행(Execution)** 이라는 명확한 목적에만 집중해야 합니다.

### **3.2. internal/ \- 비즈니스 로직 구성**

* **역할:** 애플리케이션의 핵심적인 **비즈니스 로직**을 구성하고 표현하는 패키지들의 상위 디렉토리입니다. 사용자의 요청을 처리하고, 비즈니스 규칙을 적용하며, 데이터를 관리하는 등의 실제적인 "일"을 수행하는 코드가 위치합니다. 이 구조에서는 책임 분리를 위해 주로 controller와 service 하위 디렉토리로 나뉩니다.
* **핵심 특징:** internal 내의 패키지들은 \*\*오직 lib/에 정의된 안정적인 추상화(인터페이스, 데이터 구조) 또는 동일 internal 내의 다른 계층(예: controller가 service를 사용)\*\*에만 의존하여 로직 흐름을 구성합니다. 구체적인 구현 기술이나 외부 시스템에 대한 직접적인 의존성(pkg/ 또는 cmd/ 의존)은 철저히 배제됩니다.
* **참고:** Go 언어의 internal 디렉토리는 특별한 의미를 갖습니다. 이 디렉토리 하위의 패키지는 동일한 모듈 내의 직계 부모 디렉토리 및 그 하위 디렉토리에서만 임포트할 수 있습니다.

#### **3.2.1. internal/controller/**

* **역할:** 외부 요청(HTTP, gRPC 등)을 받아 처리하고, 적절한 service를 호출하며, 결과를 외부 시스템이 이해할 수 있는 형태로 변환하여 응답하는 책임을 갖습니다. **요청/응답 처리 및 흐름 제어의 시작점**입니다.
* **구조:** 일반적으로 기능/도메인별(예: user, product) 또는 API 리소스 단위(예: /users, /orders)로 하위 패키지를 구성하여 관련 핸들러들을 그룹화합니다.
* **주요 책임:**
    * **요청 처리 및 데이터 추출:** HTTP 요청, gRPC 메시지 등 다양한 형태의 입력을 받아 필요한 데이터를 추출하고 파싱합니다.
    * **입력 유효성 검증:** 기본적인 데이터 형식 검증 및 비즈니스 규칙 관련 유효성 검증을 수행하거나 위임합니다.
    * **DTO 변환:** 외부 요청 데이터를 내부 service 계층이 이해하고 사용할 수 있는 데이터 구조로 변환합니다.
    * **서비스 호출:** 적절한 service 메서드를 호출하고 비즈니스 로직 수행을 요청합니다.
    * **결과 변환 및 응답:** service로부터 받은 결과를 클라이언트가 기대하는 형식으로 변환하고, 적절한 상태 코드와 함께 응답합니다.
    * **오류 처리:** 발생한 오류를 포착하여 적절한 오류 응답을 생성합니다.
* **의존성:** internal/service/ 및 lib/ 패키지에 의존합니다.

#### **3.2.2. internal/service/**

* **역할:** 애플리케이션의 **핵심 비즈니스 로직(Business Logic)과 유스케이스(Use Case)를 실제로 구현하고 실행**하는 계층입니다. controller로부터 요청을 받아, 필요한 데이터 조회, 비즈니스 규칙 적용, 데이터 변경, 외부 시스템 연동 등 \*\*실질적인 처리 과정을 조율(Orchestration)\*\*합니다.
* **구조:** 기능/도메인별로 하위 패키지를 구성하여 관련 서비스 로직을 그룹화합니다.
* **주요 책임:**
    * **비즈니스 규칙 적용 및 검증:** 도메인 지식에 기반한 복잡한 비즈니스 규칙을 적용하고 데이터의 정합성을 검증합니다.
    * **데이터 영속성 관리:** lib/repository 인터페이스를 통해 데이터베이스나 캐시 등 저장소의 데이터를 관리합니다.
    * **프로세스 조율 (Orchestration):** 특정 유스케이스를 완료하기 위해 여러 repository, domain 서비스, adapter 호출 등을 조율합니다.
    * **외부 시스템 연동:** lib/adapter 인터페이스를 통해 외부 API 호출, 메시지 큐 발행/구독 등을 수행합니다.
    * **트랜잭션 관리:** 필요한 경우 데이터 변경 작업의 원자성을 보장하기 위해 트랜잭션을 관리합니다.
    * **도메인 이벤트 발행:** 비즈니스 로직 수행 결과 발생하는 의미 있는 사건을 이벤트로 발행합니다.
* **의존성:** 오직 lib/ 패키지에만 의존합니다.

### **3.3. lib/ \- 핵심 추상화**

* **역할:** 프로젝트의 **가장 근본적이고 안정적인 추상화 계층**입니다. 특정 기술이나 구현에 독립적인 **인터페이스**, 공유 **데이터 구조**(VO, Entity, DTO 등), 핵심 **도메인 모델** 정의를 포함합니다.
* **핵심 특징:** **구체적인 구현 코드가 전혀 포함되지 않은** 순수한 \*\*정의(Definitions)\*\*만 존재합니다. 다른 모든 내부 계층(internal, pkg, cmd)이 의존하는 기반 역할을 하며, 가장 변경 빈도가 낮아야 합니다.
* **데이터 구조 정의:** DTO, VO, Entity 등은 이 lib의 적절한 하위 패키지(예: lib/repository/user, lib/domain/order) 내에 관련 인터페이스와 함께 정의됩니다.
* **의존성:** **다른 어떤 내부 패키지에도 의존하지 않으며,** 외부 라이브러리 의존성도 최소화합니다.
* **구조:** 역할별로 하위 디렉토리를 구성합니다.
    * adapter/: 외부 시스템과의 통신 방식을 추상화하는 인터페이스 및 관련 데이터 구조 정의.
    * gen/: IDL 파일로부터 자동 생성된 Go 코드 저장.
    * repository/: 데이터 영속성 계층 접근 인터페이스 및 관련 데이터 구조 정의.
    * domain/: 핵심 비즈니스 규칙, 도메인 모델, 도메인 서비스 인터페이스 및 관련 타입 정의.
* **하위 구조:** 각 하위 디렉토리 아래에는 기능/도메인별로 패키지를 더 세분화합니다.

### **3.4. pkg/ \- 구현**

* **역할:** lib/ 디렉토리에 정의된 \*\*인터페이스들의 구체적인 구현체(Concrete Implementations)\*\*가 위치하는 곳입니다. 실제 외부 라이브러리 사용, 특정 기술 의존 로직, 인프라스트럭처 관련 코드가 여기에 해당합니다.
* **구조:** **구체적인 구현 방식, 기술, 라이브러리, 또는 외부 시스템**을 기준으로 하위 디렉토리를 구성합니다 (예: pkg/db/postgres, pkg/cache/redis, pkg/logger/zerolog).
* **핵심 특징:** lib/의 인터페이스를 실제로 구현하는 코드가 위치합니다.
* **의존성:** 자신이 구현하는 인터페이스가 정의된 lib/ 패키지에 의존합니다. **절대로 internal/ 패키지에 의존해서는 안 됩니다.**

### **3.5. proto/ \- 프로토콜 정의**

* **역할:** Protocol Buffers (.proto), OpenAPI/Swagger (.yaml, .json) 등 **IDL(Interface Definition Language) 원본 파일** 및 관련 명세서를 관리합니다.
* **주의:** 여기서 정의된 파일로부터 **자동 생성된 Go 코드**는 lib/gen/ 디렉토리에 위치합니다.

## **4\. 핵심 원칙 요약**

이 패키지 구조를 효과적으로 활용하기 위해 반드시 이해하고 준수해야 할 핵심 원칙들은 다음과 같습니다.

* **명확한 계층 분리:** lib/(핵심 추상화) → internal/service/(비즈니스 로직) → internal/controller/(요청 처리) → cmd/(실행/조립). pkg/(구현)는 lib/를 구현하며 다른 계층과 분리됩니다.
* **엄격한 인터페이스/구현 분리:** lib/는 정의만, pkg/는 lib/의 구현만 담당합니다. internal 계층은 lib/ 인터페이스를 사용하여 로직을 구성합니다.
* **단방향 의존성:** 의존성은 항상 바깥 계층에서 안쪽의 더 안정적인 계층으로 향해야 합니다 (cmd/ → internal/, pkg/ → lib/, internal/ → lib/). \*\*pkg/\*\*는 \*\*internal/\*\*에 의존하지 않으며, \*\*service\*\*는 \*\*controller\*\*에 의존하지 않습니다.
* **구현 중심 pkg/ 구조:** pkg/는 특정 기술이나 라이브러리 등 구체적인 '구현 방식'을 기준으로 구성됩니다.
* **의존성 주입 (DI) 활용:** 계층 간의 실제적인 연결은 인터페이스를 통해 느슨하게 이루어지며, 구체적인 구현체는 cmd/에서 조립하여 주입합니다.
* **데이터 구조 위치:** DTO, VO 등 데이터 구조는 관련된 인터페이스나 로직이 정의된 패키지 내(주로 lib의 하위 패키지)에 함께 위치시켜 응집도를 높입니다.

## **5\. 다른 레이어드 아키텍처와의 비교**

### **5.1. 아키텍처 개요**

* **헥사고날 아키텍처 (Ports and Adapters):** 핵심 비즈니스 로직(Core)을 중심으로, 외부와의 상호작용을 위한 인터페이스(Ports)와 그 구현체(Adapters)로 구성됩니다. 의존성은 항상 외부(Adapter)에서 내부(Core)를 향합니다.
* **어니언 아키텍처:** 도메인 모델(Domain Model)을 가장 안쪽에 두고, 도메인 서비스, 애플리케이션 서비스, 인프라스트럭처 순으로 계층을 구성합니다. 의존성은 항상 바깥 계층에서 안쪽 계층(도메인 모델)을 향합니다.

### **5.2. 공통점**

세 가지 아키텍처(제시된 Go 구조 포함) 모두 **관심사 분리**, **의존성 역전 원칙** 준수, **테스트 용이성** 향상, **유지보수성 및 유연성** 확보라는 공통 목표를 가집니다. 핵심 비즈니스 로직을 외부 변화로부터 보호하는 데 중점을 둡니다.

### **5.3. 차이점 및 Go 구조와의 매핑**

| 특징 | 제시된 Go 구조 | 헥사고날 아키텍처 | 어니언 아키텍처 |
| :---- | :---- | :---- | :---- |
| **핵심 로직** | internal/service/, lib/domain/ | Core (Application/Domain) | Domain Model, Domain Services, App Services |
| **추상화/인터페이스** | lib/ (모든 인터페이스 중앙 집중) | Ports (Primary/Secondary) | Inner Layers 에서 정의 |
| **구현/인프라** | pkg/ (기술별 구현체) | Adapters (Primary/Secondary) | Outermost Layer (Infrastructure) |
| **요청 처리** | internal/controller/ | Primary Adapters | UI / Infrastructure Layer |
| **의존성 주입** | cmd/ | 구성 루트 (명시적 디렉토리 없음) | 구성 루트 (명시적 디렉토리 없음) |
| **주요 강조점** | Go 특성 활용, pkg의 기술 중심 분리, lib의 중앙 집중 | Core와 외부 간 명확한 경계(Ports) | 도메인 모델 중심의 동심원 구조 |

제시된 Go 구조는 헥사고날이나 어니언 아키텍처의 핵심 원칙을 따르면서도, Go 언어의 특성과 커뮤니티 컨벤션을 반영한 실용적인 형태입니다. 특히 lib에 모든 인터페이스를 중앙 집중화하고, pkg를 구현 기술별로 명확히 분리하는 점이 특징입니다.

## **6\. 결론: 견고하고 유연한 Go 애플리케이션 구축을 위한 제언**

본 가이드에서 제시된 패키지 구조는 단순히 디렉토리를 나누는 것을 넘어, Go 애플리케이션을 **견고하고(Robust), 유연하며(Flexible), 지속 가능하게(Sustainable)** 만들기 위한 설계 철학을 담고 있습니다.

**주요 이점:**

* **향상된 유지보수성:** 역할 분리가 명확하여 코드 이해 및 수정이 용이하고 변경 영향 범위를 제한합니다.
* **증가된 확장성:** 새로운 기능 추가나 기술 교체가 용이하며 기존 코드에 미치는 영향을 최소화합니다.
* **높은 테스트 용이성:** 인터페이스 기반 설계와 DI는 컴포넌트 격리 및 단위 테스트 작성을 용이하게 합니다.
* **강화된 팀 협업:** 일관된 구조는 코드 컨벤션을 맞추고 협업 효율성을 높입니다.
* **낮은 결합도, 높은 응집도:** 단방향 의존성과 인터페이스 분리는 결합도를 낮추고, 관련 코드를 함께 배치하여 응집도를 높입니다.

**적용 시 고려사항:**

이 구조는 모든 프로젝트에 완벽하게 맞는 만능 해결책은 아닐 수 있습니다. 프로젝트의 규모, 복잡성, 팀의 경험 등을 고려하여 세부 사항을 조정할 수 있습니다. 중요한 것은 형식적인 디렉토리 구조 자체가 아니라, 그 안에 담긴 **핵심 원칙(계층 분리, 단방향 의존성, 인터페이스 기반 설계, 의존성 주입)을 이해하고 일관성 있게 적용**하는 것입니다.

이 원칙들을 준수한다면, 프로젝트가 성장하고 변화함에 따라 발생할 수 있는 복잡성을 효과적으로 관리하고, 장기적으로 안정적이고 효율적인 개발 프로세스를 유지할 수 있을 것입니다. 궁극적으로 이 패키지 구조 가이드는 Go 언어의 장점을 살리면서 복잡한 소프트웨어를 성공적으로 구축하고 발전시켜 나가는 데 튼튼한 기반을 제공할 것입니다.